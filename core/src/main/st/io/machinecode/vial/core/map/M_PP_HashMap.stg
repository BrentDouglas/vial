delimiters "$", "$"

PPHashMap(I, P, p, hc, X) ::= <<
package io.machinecode.vial.core.map;

import io.machinecode.vial.api.OIterator;
import io.machinecode.vial.api.Spread;
import io.machinecode.vial.core.Spreads;
import io.machinecode.vial.api.map.$I$$I$Cursor;
import io.machinecode.vial.api.map.$I$$I$Map;
import io.machinecode.vial.core.Util;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * @author <a href="mailto:brent.n.douglas@gmail.com">Brent Douglas</a>
 * @since 1.0
 */
public class $I$$I$HashMap implements $I$$I$Map, Serializable {
    private static final long serialVersionUID = 0L;

    private static final int MAX_CAPACITY = 1 << 29;
    private static final int MIN_CAPACITY = 4;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    private static final $p$ NO_KEY = 0;
    private static final $p$ NO_VALUE = 0;

    private $p$[] _data;
    private boolean _haveNoValue;
    private $p$ _noValue;

    private final Spread _spread;
    private final float _factor;
    private int _threshold;
    private int _size;

    private int _initialMask;
    private int _nextMask;

    public $I$$I$HashMap() {
        this(MIN_CAPACITY, DEFAULT_LOAD_FACTOR, Spreads.QUICK);
    }

    public $I$$I$HashMap(final int capacity) {
        this(capacity, DEFAULT_LOAD_FACTOR, Spreads.QUICK);
    }

    public $I$$I$HashMap(final float factor) {
        this(MIN_CAPACITY, factor, Spreads.QUICK);
    }

    public $I$$I$HashMap(final Map<? extends $P$, ? extends $P$> m) {
        if (m instanceof $I$$I$HashMap) {
            final $I$$I$HashMap x = ($I$$I$HashMap)m;
            this._spread = x._spread;
            this._factor = x._factor;
            this._size = x._size;
            this._threshold = x._threshold;
            this._initialMask = x._initialMask;
            this._nextMask = x._nextMask;
            this._haveNoValue = x._haveNoValue;
            this._noValue = x._noValue;
            this._data = new $p$[x._data.length];
            System.arraycopy(x._data, 0, this._data, 0, x._data.length);
        } else {
            this._spread = Spreads.QUICK;
            this._factor = DEFAULT_LOAD_FACTOR;
            final int capacity = Math.max((int) (m.size() / this._factor) + 1, MIN_CAPACITY);
            this._size = 0;
            final int cap = Util.capacity(capacity, this._factor, MAX_CAPACITY);
            this._threshold = (int)(cap * this._factor);
            final int length = cap * 2;
            this._initialMask = cap - 1;
            this._nextMask = length - 1;
            this._data = new $p$[length];
            putAll(m);
        }
    }

    public $I$$I$HashMap(final int capacity, final float factor) {
        this(capacity, factor, Spreads.QUICK);
    }

    public $I$$I$HashMap(final int _capacity, final float factor, final Spread spread) {
        assert factor > 0 && factor <= 1;
        assert spread != null;
        assert _capacity >= 0;
        this._spread = spread;
        final int capacity = Math.max((int) (_capacity / factor) + 1, MIN_CAPACITY);
        this._factor = factor;
        this._size = 0;
        final int cap = Util.capacity(capacity, factor, MAX_CAPACITY);
        final int length = cap * 2;
        this._threshold = (int)(cap * factor);
        this._initialMask = cap - 1;
        this._nextMask = length - 1;
        this._data = new $p$[length];
    }

    @Override
    public int size() {
        return _size;
    }

    @Override
    public boolean isEmpty() {
        return _size == 0;
    }

    @Override
    public boolean containsKey(final Object key) {
        return key instanceof $P$ && xcontainsKey(($p$)key);
    }

    @Override
    public boolean xcontainsKey(final $p$ key) {
        if (key == NO_KEY) {
            return this._haveNoValue;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return false;
            } else if (k == key) {
                return true;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $p$ nv() {
        return NO_VALUE;
    }

    @Override
    public boolean containsValue(final Object value) {
        return value instanceof $P$ && xcontainsValue(($p$)value);
    }

    @Override
    public boolean xcontainsValue(final $p$ value) {
        if (_haveNoValue && _noValue == value) {
            return true;
        }
        final $p$[] data = this._data;
        for (int i = 0, len = data.length; i < len; i+=2) {
            final $p$ k = data[i];
            if (k != NO_KEY && data[i+1] == value) {
                return true;
            }
        }
        return false;
    }

    @Override
    public $P$ get(final Object _key) {
        if (!(_key instanceof $P$)) {
            return null;
        }
        final $p$ key = ($p$)_key;
        if (key == NO_KEY) {
            return this._haveNoValue
                    ? this._noValue
                    : null;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return null;
            } else if (k == key) {
                return data[index + 1];
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $p$ xget(final $p$ key) {
        if (key == NO_KEY) {
            return this._haveNoValue
                    ? this._noValue
                    : NO_VALUE;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return NO_VALUE;
            } else if (k == key) {
                return data[index + 1];
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $P$ getOrDefault(final Object key, final $P$ defaultValue) {
        if (key instanceof $P$) {
            return xgetOrDefault(($p$) key, ($p$)defaultValue);
        } else {
            return defaultValue;
        }
    }

    @Override
    public $p$ xgetOrDefault(final $p$ key, final $p$ defaultValue) {
        if (key == NO_KEY) {
            return this._haveNoValue
                    ? this._noValue
                    : defaultValue;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return defaultValue;
            } else if (k == key) {
                return data[index + 1];
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $I$$I$HashMap with(final $p$ key, final $p$ value) {
        xput(key, value);
        return this;
    }

    @Override
    public $P$ put(final $P$ _key, final $P$ _value) {
        final $p$ key = _key;
        final $p$ value = _value;
        if (key == NO_KEY) {
            final $P$ old;
            if (!this._haveNoValue) {
                this._size++;
                old = null;
            } else {
                old = this._noValue;
            }
            this._noValue = value;
            this._haveNoValue = true;
            return old;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                data[index] = key;
                data[index + 1] = value;
                if (++this._size >= this._threshold) {
                    _rehash(Util.capacity(data.length / 2, this._factor, MAX_CAPACITY));
                }
                return null;
            } else if (k == key) {
                final $p$ old = data[index + 1];
                data[index + 1] = value;
                return old;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $p$ xput(final $p$ key, final $p$ value) {
        if (key == NO_KEY) {
            final $p$ old;
            if (!this._haveNoValue) {
                this._size++;
                old = NO_VALUE;
            } else {
                old = this._noValue;
            }
            this._noValue = value;
            this._haveNoValue = true;
            return old;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                data[index] = key;
                data[index + 1] = value;
                if (++this._size >= this._threshold) {
                    _rehash(Util.capacity(data.length / 2, this._factor, MAX_CAPACITY));
                }
                return NO_VALUE;
            } else if (k == key) {
                final $p$ old = data[index + 1];
                data[index + 1] = value;
                return old;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $P$ putIfAbsent(final $P$ _key, final $P$ _value) {
        final $p$ key = _key;
        final $p$ value = _value;
        if (key == NO_KEY) {
            if (this._haveNoValue) {
                return this._noValue;
            }
            this._size++;
            this._noValue = value;
            this._haveNoValue = true;
            return null;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                data[index] = key;
                data[index + 1] = value;
                if (++this._size >= this._threshold) {
                    _rehash(Util.capacity(data.length / 2, this._factor, MAX_CAPACITY));
                }
                return null;
            } else if (k == key) {
                return data[index + 1];
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $p$ xputIfAbsent(final $p$ key, final $p$ value) {
        if (key == NO_KEY) {
            if (this._haveNoValue) {
                return this._noValue;
            }
            this._size++;
            this._noValue = value;
            this._haveNoValue = true;
            return NO_VALUE;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                data[index] = key;
                data[index + 1] = value;
                if (++this._size >= this._threshold) {
                    _rehash(Util.capacity(data.length / 2, this._factor, MAX_CAPACITY));
                }
                return NO_VALUE;
            } else if (k == key) {
                return data[index + 1];
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void putAll(final Map<? extends $P$, ? extends $P$> m) {
        final int s = m.size();
        if (s == 0) {
            return;
        }
        _expand(this._size + s);
        // TODO
        //if (m instanceof $I$$I$Map) {
        //    final $I$$I$Map x = ($I$$I$Map)m;
        //    final $I$[] data = x._data;
        //    for (int i = 0, len = data.length; i < len; i+=2) {
        //        if (data[i] == NO_KEY) {
        //            continue;
        //        }
        //        xput(data[i], data[i + 1]);
        //    }
        //    if (x._haveNoValue) {
        //        this._noValue = x._noValue;
        //    }
        //} else
        if (m instanceof $I$$I$Map) {
            for (final $I$$I$Cursor entry : (($I$$I$Map)m)) {
                xput(entry.key(), entry.value());
            }
        } else {
            for (final Entry<? extends $P$, ? extends $P$> entry : m.entrySet()) {
                xput(entry.getKey().$p$Value(), entry.getValue().$p$Value());
            }
        }
    }

    @Override
    public $P$ remove(final Object _key) {
        if (!(_key instanceof $P$)) {
            return null;
        }
        final $p$ key = ($p$)_key;
        if (key == NO_KEY) {
            if (this._haveNoValue) {
                this._size--;
                this._haveNoValue = false;
                return this._noValue;
            } else {
                return null;
            }
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return null;
            } else if (k == key) {
                final $p$ old = data[index + 1];
                _remove(index);
                return old;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $p$ xremove(final $p$ key) {
        if (key == NO_KEY) {
            if (this._haveNoValue) {
                this._size--;
                this._haveNoValue = false;
                return this._noValue;
            } else {
                return NO_VALUE;
            }
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return NO_VALUE;
            } else if (k == key) {
                final $p$ old = data[index + 1];
                _remove(index);
                return old;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public boolean remove(final Object key, final Object value) {
        return key instanceof $P$ && value instanceof $P$ && xremove(($p$) key, ($p$) value);
    }

    @Override
    public boolean xremove(final $p$ key, final $p$ value) {
        if (key == NO_KEY) {
            if (this._haveNoValue && value == this._noValue) {
                this._size--;
                this._haveNoValue = false;
                return true;
            } else {
                return false;
            }
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return false;
            } else if (k == key) {
                if (value != data[index + 1]) {
                    return false;
                }
                _remove(index);
                return true;
            }
            index = (index + 2) & nm;
        }
    }

    private boolean _removeKey(final $p$ key) {
        if (key == NO_KEY) {
            if (this._haveNoValue) {
                this._size--;
                this._haveNoValue = false;
                return true;
            } else {
                return false;
            }
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return false;
            } else if (k == key) {
                _remove(index);
                return true;
            }
            index = (index + 2) & nm;
        }
    }

    private void _remove(int index) {
        this._size--;
        final $p$[] data = this._data;
        final Spread spread = this._spread;
        final int im = this._initialMask;
        final int nm = this._nextMask;
        int next = (index + 2) & nm;
        for (;;) {
            final $p$ key = data[next];
            if (key == NO_KEY) {
                data[index] = NO_KEY;
                return;
            }
            final int hash = spread.spread($hc$);
            int slot = (hash & im) << 1;
            if (index <= next
                    ? index >= slot || slot > next
                    : index >= slot && slot > next) {
                data[index] = key;
                data[index+1] = data[next+1];
                index = next;
            }
            next = (next + 2) & nm;
        }
    }

    @Override
    public boolean xremoveValue(final $p$ value) {
        if (_haveNoValue && (value == NO_VALUE ? _noValue == NO_VALUE : value == _noValue)) {
            _haveNoValue = false;
            --_size;
            return true;
        }
        final $p$[] data = this._data;
        for (int i = 0, len = data.length; i < len; i+=2) {
            final $p$ k = data[i];
            final $p$ v = data[i+1];
            if (k != NO_KEY && (value == NO_VALUE ? v == NO_VALUE : value == v)) {
                _remove(i);
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean replace(final $P$ key, final $P$ oldValue, final $P$ newValue) {
        return xreplace(($p$)key, ($p$)oldValue, ($p$)newValue);
    }

    @Override
    public boolean xreplace(final $p$ key, final $p$ oldValue, final $p$ newValue) {
        if (key == NO_KEY) {
            if (!this._haveNoValue || this._noValue != oldValue) {
                return false;
            }
            this._noValue = newValue;
            this._haveNoValue = true;
            return true;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return false;
            } else if (k == key) {
                if (data[index + 1] != oldValue) {
                    return false;
                }
                data[index + 1] = newValue;
                return true;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $P$ replace(final $P$ _key, final $P$ _value) {
        final $p$ key = _key;
        final $p$ value = _value;
        if (key == NO_KEY) {
            if (!this._haveNoValue) {
                return null;
            }
            final $p$ old = this._noValue;
            this._noValue = value;
            this._haveNoValue = true;
            return old;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return null;
            } else if (k == key) {
                final $p$ old = data[index + 1];
                data[index + 1] = value;
                return old;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public $p$ xreplace(final $p$ key, final $p$ value) {
        if (key == NO_KEY) {
            if (!this._haveNoValue) {
                return NO_VALUE;
            }
            final $p$ old = this._noValue;
            this._noValue = value;
            this._haveNoValue = true;
            return old;
        }
        final $p$[] data = this._data;
        final int nm = this._nextMask;
        final int hash = _spread.spread($hc$);
        int index = (hash & this._initialMask) << 1;
        for (;;) {
            final $p$ k = data[index];
            if (k == NO_KEY) {
                return NO_VALUE;
            } else if (k == key) {
                final $p$ old = data[index + 1];
                data[index + 1] = value;
                return old;
            }
            index = (index + 2) & nm;
        }
    }

    @Override
    public void clear() {
        this._haveNoValue = false;
        this._size = 0;
        //TODO This is slow for byte keys
        final $p$[] data = this._data;
        for (int i = 0, len = data.length; i < len; i+=2) {
            data[i] = NO_KEY;
        }
    }

    @Override
    public Set<$P$> keySet() {
        return new KeySet(this);
    }

    @Override
    public Collection<$P$> values() {
        return new ValueCol(this);
    }

    @Override
    public Set<Entry<$P$, $P$$X$ entrySet() {
        return new EntrySet(this);
    }

    @Override
    public $I$$I$Cursor iterator() {
        return new CursorIt(this);
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null) return false;
        if (o instanceof $I$$I$Map) {
            final $I$$I$Map m = ($I$$I$Map) o;
            if (_size != m.size()) return false;
            for (final $I$$I$Cursor e : this) {
                if (e.value() != m.xget(e.key())) return false;
            }
            return true;
        } else if (o instanceof Map) {
            final Map<?,?> m = (Map<?,?>) o;
            if (_size != m.size()) return false;
            for (final $I$$I$Cursor e : this) {
                final Object value = m.get(e.key());
                if (value == null || !value.equals(e.value())) return false;
            }
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        int ret = 0;
        for (final $I$$I$Cursor e : this) {
            ret += e.hashCode();
        }
        return ret;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("{");
        boolean add = false;
        for (final $I$$I$Cursor e : this) {
            if (add) {
                sb.append(", ");
            }
            sb.append(e.key()).append("=").append(e.value());
            add = true;
        }
        return sb.append('}').toString();
    }

    @Override
    public $I$$I$HashMap capacity(final int desired) {
        final int size = Math.max(this._size, MIN_CAPACITY);
        if (desired <= size) {
            return this;
        }
        final float factor = this._factor;
        final int pow2desired = Util.capacity(desired, factor, MAX_CAPACITY);
        final int current = this._data.length / 2;
        if (pow2desired == current || size >= pow2desired) {
            return this;
        }
        final int pow2min = Util.capacity(size, factor, MAX_CAPACITY);
        if (pow2desired < pow2min) {
            return this;
        }
        _rehash(pow2desired);
        return this;
    }

    private void _expand(final int desired) {
        final int len = this._data.length / 2;
        if (desired <= len) {
            return;
        }
        _rehash(Util.capacity(desired, this._factor, MAX_CAPACITY));
    }

    private void _rehash(final int capacity) {
        final int length = capacity * 2;
        this._threshold = (int)(capacity * this._factor);
        final int im = this._initialMask = capacity - 1;
        final int nm = this._nextMask = length - 1;
        final $p$[] data = this._data;
        final $p$[] newData = this._data = new $p$[length];
        final Spread spread = this._spread;
        outer: for (int i = 0, len = data.length; i < len; i+=2) {
            final $p$ key = data[i];
            if (key == NO_KEY) {
                continue;
            }
            final $p$ value = data[i+1];
            final int hash = spread.spread($hc$);
            int index = (hash & im) << 1;
            for (;;) {
                final $p$ k = newData[index];
                if (k == NO_KEY) {
                    newData[index] = key;
                    newData[index + 1] = value;
                    continue outer;
                } else if (k == key) {
                    newData[index + 1] = value;
                    continue outer;
                }
                index = (index + 2) & nm;
            }
        }
    }

    private abstract static class _It<T> implements OIterator<T> {
        private static final $p$ ILLEGAL = ($p$)-1;
        private static final int INDEX_BEFORE = -1;
        private static final int INDEX_NO_VALUE = -2;
        private static final int INDEX_FINISHED = -3;

        final $I$$I$HashMap map;
        private $p$[] data;
        private int index = INDEX_BEFORE;
        $p$ key = ILLEGAL;
        int keyIndex = -1;
        private boolean found = false;

        private _It(final $I$$I$HashMap map) {
            this.map = map;
            this.data = map._data;
        }

        private void _advance() {
            assert !found;
            assert index != INDEX_FINISHED;
            switch (index) {
                case INDEX_NO_VALUE:
                    index = INDEX_FINISHED;
                    found = true;
                    return;
                case INDEX_BEFORE:
                    index = 0;
                    break;
                default:
                    index+=2;
                    break;
            }
            final $p$[] data = this.data;
            for (int i = index, len = data.length; i < len; i+=2) {
                if (data[i] == NO_KEY) {
                    continue;
                }
                index = i;
                found = true;
                return;
            }
            index = map._haveNoValue ? INDEX_NO_VALUE : INDEX_FINISHED;
            found = true;
        }

        @Override
        public boolean hasNext() {
            if (!found) _advance();
            assert index != INDEX_BEFORE;
            return index != INDEX_FINISHED;
        }

        @Override
        public T next() {
            if (!found) _advance();
            assert index != INDEX_BEFORE;
            switch (index) {
                case INDEX_FINISHED:
                    throw new NoSuchElementException(); //TODO Message
                case INDEX_NO_VALUE:
                    assert map._haveNoValue;
                    key = NO_KEY;
                    break;
                default:
                    assert index > INDEX_BEFORE && index < data.length;
                    key = data[keyIndex = index];
            }
            found = false;
            return _get();
        }

        @Override
        public void remove() {
            if (key == ILLEGAL) {
                throw new IllegalStateException(); //TODO Message
            }
            if (key == NO_KEY) {
                assert map._haveNoValue;
                --map._size;
                map._haveNoValue = false;
            } else {
                assert keyIndex >= 0;
                assert this.data[keyIndex] != NO_KEY;
                if (this.data == map._data) {
                    _removeAndCopy(keyIndex);
                } else {
                    map._removeKey(key);
                }
            }
            key = ILLEGAL;
        }

        private void _removeAndCopy(final int remove) {
            assert this.data == map._data;
            map._size--;
            final $p$[] mapData = map._data;
            $p$[] data = mapData;
            final Spread spread = map._spread;
            final int im = map._initialMask;
            final int nm = map._nextMask;
            int index = remove;
            int next = (index + 2) & nm;
            for (;;) {
                final $p$ key = mapData[next];
                if (key == NO_KEY) {
                    mapData[index] = NO_KEY;
                    return;
                }
                final int hash = spread.spread($hc$);
                int slot = (hash & im) << 1;
                if (index <= next
                        ? index >= slot || slot > next
                        : index >= slot && slot > next) {
                    if (next < remove && index >= remove && data == mapData) {
                        mapData[index] = NO_KEY;
                        this.data  = data = new $p$[mapData.length - remove];
                        System.arraycopy(mapData, remove, data, 0, data.length);
                    }
                    mapData[index] = key;
                    mapData[index+1] = mapData[next+1];
                    int i = this.index = data == mapData ? remove : 0;
                    this.found = data[i] != NO_KEY;
                    index = next;
                }
                next = (next + 2) & nm;
            }
        }

        @Override
        public _It<T> before() {
            index = INDEX_BEFORE;
            found = false;
            key = ILLEGAL;
            data = map._data;
            return this;
        }

        @Override
        public _It<T> after() {
            index = INDEX_FINISHED;
            found = true;
            key = ILLEGAL;
            data = map._data;
            return this;
        }

        @Override
        public _It<T> index(final int index) {
            if (index >= map._size) throw new IndexOutOfBoundsException();
            this.index = INDEX_BEFORE;
            key = ILLEGAL;
            found = true;
            final $p$[] data = this.data;
            int x = 0;
            for (int i = 0, len = data.length; i < len; ++i) {
                if (data[i] == NO_KEY) {
                    continue;
                }
                if (x++ == index) {
                    this.index = i;
                    return this;
                }
            }
            this.index = map._haveNoValue ? INDEX_NO_VALUE : INDEX_FINISHED;
            return this;
        }

        abstract T _get();
    }

    private static class CursorIt extends _It<$I$$I$Cursor> implements $I$$I$Cursor {
        private CursorIt(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        $I$$I$Cursor _get() {
            return this;
        }

        @Override
        public $p$ key() {
            return key;
        }

        @Override
        public $p$ value() {
            return key == NO_KEY ? map._noValue : map._data[keyIndex+1];
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) return true;
            if (o == null || !(o instanceof $I$$I$Cursor)) return false;
            final $I$$I$Cursor c = ($I$$I$Cursor) o;

            final $p$ key = key();
            final $p$ value = value();
            final $p$ ckey = c.key();
            final $p$ cvalue = c.value();
            return (key == ckey) && (value == cvalue);
        }

        @Override
        public int hashCode() {
            final $p$ key = key();
            final $p$ value = value();
            return $P$.hashCode(key) ^ $P$.hashCode(value);
        }

        @Override
        public String toString() {
            final StringBuilder sb = new StringBuilder();
            sb.append(key()).append("=").append(value());
            return sb.toString();
        }

        @Override
        public $I$$I$Cursor iterator() {
            return this;
        }
    }

    private static class EntryIt extends _It<Entry<$P$,$P$$X$ {

        private EntryIt(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        Entry<$P$,$P$> _get() {
            return new En<>(map, key, key == NO_KEY ? map._noValue : map._data[keyIndex+1]);
        }
    }

    private static class KeyIt extends _It<$P$> {
        private KeyIt(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        $P$ _get() {
            return key;
        }
    }

    private static class ValueIt extends _It<$P$> {
        private ValueIt(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        $P$ _get() {
            return key == NO_KEY ? map._noValue : map._data[keyIndex+1];
        }
    }

    private abstract static class _Col<X> implements Collection<X> {
        final $I$$I$HashMap map;

        private _Col(final $I$$I$HashMap map) {
            this.map = map;
        }

        @Override
        public int size() {
            return map._size;
        }

        @Override
        public boolean isEmpty() {
            return map._size == 0;
        }

        @Override
        public boolean add(final X e) {
            throw new UnsupportedOperationException(); //TODO Message
        }

        @Override
        public boolean addAll(final Collection<? extends X> c) {
            throw new UnsupportedOperationException(); //TODO Message
        }

        @Override
        public boolean containsAll(final Collection<?> c) {
            for (final Object o : c) {
                if (!contains(o)) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean removeAll(final Collection<?> c) {
            boolean ret = false;
            for (final Object o : c) {
                ret |= remove(o);
            }
            return ret;
        }

        @Override
        public boolean retainAll(final Collection<?> c) {
            if (c == null) throw new NullPointerException(); //TODO Message
            final Iterator<X> it = _Col.this.iterator();
            boolean ret = false;
            while (it.hasNext()) {
                if (!c.contains(it.next())) {
                    it.remove();
                    ret = true;
                }
            }
            return ret;
        }

        @Override
        public Object[] toArray() {
            final Object[] ret = new Object[map._size];
            int ri = 0;
            if (map._haveNoValue) {
                ret[ri++] = _get(NO_KEY);
            }
            for (int i = 0; i < map._data.length; i+=2) {
                final $p$ key = map._data[i];
                if (key == NO_KEY) {
                    continue;
                }
                ret[ri++] = _get(key);
            }
            return ret;
        }

        @Override
        @SuppressWarnings("unchecked")
        public <T> T[] toArray(final T[] a) {
            final T[] ret;
            if (a.length == map._size) {
                ret = a;
            } else if (a.length > map._size) {
                ret = a;
                a[map._size] = null;
            } else {
                ret = (T[])Array.newInstance(a.getClass().getComponentType(), map._size);
            }
            int ri = 0;
            if (map._haveNoValue) {
                ret[ri++] = (T)_get(NO_KEY);
            }
            for (int i = 0; i < map._data.length; i+=2) {
                final $p$ key = map._data[i];
                if (key == NO_KEY) {
                    continue;
                }
                ret[ri++] = (T)_get(key);
            }
            return ret;
        }

        abstract X _get(final $p$ key);

        @Override
        public void clear() {
            map.clear();
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) return true;
            if (o == null || !(o instanceof Collection)) return false;
            final Collection<?> c = (Collection<?>) o;
            return c.size() == size() && containsAll(c);
        }

        @Override
        public int hashCode() {
            int h = 0;
            for (final X x : _Col.this) {
                h += x.hashCode();
            }
            return h;
        }

        @Override
        public String toString() {
            final StringBuilder sb = new StringBuilder("[");
            boolean add = false;
            for (final X e : this) {
                if (add) {
                    sb.append(',');
                }
                sb.append(e);
                add = true;
            }
            return sb.append(']').toString();
        }
    }

    private static class KeySet extends _Col<$P$> implements Set<$P$> {

        private KeySet(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        public boolean contains(final Object o) {
            return map.containsKey(o);
        }

        @Override
        public Iterator<$P$> iterator() {
            return new KeyIt(map);
        }

        @Override
        public boolean remove(final Object o) {
            return o instanceof $P$ && map._removeKey(($p$)o);
        }

        @Override
        $P$ _get(final $p$ key) {
            return key;
        }

        @Override
        public boolean equals(final Object o) {
            return o instanceof Set && super.equals(o);
        }
    }

    private static class ValueCol extends _Col<$P$> {
        private ValueCol(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        $P$ _get(final $p$ key) {
            return map.xget(key);
        }

        @Override
        public boolean contains(final Object o) {
            return map.containsValue(o);
        }

        @Override
        public Iterator<$P$> iterator() {
            return new ValueIt(map);
        }

        @Override
        public boolean remove(final Object o) {
            return o instanceof $P$ && map.xremoveValue(($p$)o);
        }
    }

    private static class EntrySet extends _Col<Entry<$P$,$P$$X$ implements Set<Entry<$P$,$P$$X$ {

        private EntrySet(final $I$$I$HashMap map) {
            super(map);
        }

        @Override
        public boolean contains(final Object o) {
            if (!(o instanceof Entry)) {
                return false;
            }
            final Entry<?,?> e = (Entry<?,?>)o;
            final Object key = e.getKey();
            if (!map.containsKey(key)) return false;
            final $p$ value = map.xget(($p$)key);
            final Object evalue = e.getValue();
            return evalue != null && evalue.equals(value);
        }

        @Override
        public Iterator<Entry<$P$,$P$$X$ iterator() {
            return new EntryIt(map);
        }

        @Override
        Entry<$P$,$P$> _get(final $p$ key) {
            return new En<>(map, key, map.xget(key));
        }

        @Override
        public boolean remove(final Object o) {
            if (!(o instanceof Entry)) {
                return false;
            }
            final Entry<?,?> e = (Entry<?,?>)o;
            return map.remove(e.getKey(), e.getValue());
        }

        @Override
        public boolean equals(final Object o) {
            return o instanceof Set && super.equals(o);
        }
    }
}
>>
